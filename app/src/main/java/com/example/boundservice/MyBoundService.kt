package com.example.boundservice

import android.app.*
import android.content.Intent
import android.os.Binder
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.compose.runtime.mutableStateOf
import androidx.core.app.NotificationCompat
import androidx.core.app.NotificationManagerCompat
import androidx.lifecycle.MutableLiveData
import java.util.*
import kotlin.concurrent.thread


class MyBoundService() : Service() {
    // Binder given to clients (notice class declaration below)
    private val mBinder: IBinder = MyBinder()

    // Random number generator
    private val mGenerator: Random = Random()

    // LiveData for capturing random number generated by the service
    val randomNumberLiveData: MutableLiveData<Int> = MutableLiveData()

    // Channel ID for notification
    private val channelId = "Random number notification"

    // Boolean to check whether the thread is running
    private val isRunning = mutableStateOf(false)

    /**
     * Class used for the client Binder. The Binder object is responsible for returning an instance
     * of "MyService" to the client.
     */
    inner class MyBinder : Binder() {
        // Return this instance of MyService so clients can call public methods
        val service: MyBoundService
            get() =// Return this instance of MyService so clients can call public methods
                this@MyBoundService
    }

    /**
     * This is how the client gets the IBinder object from the service.
     */
    override fun onBind(intent: Intent): IBinder? {
        return mBinder
    }

    /**
     * Called when service is created So  we will do our work here
     */
    override fun onCreate() {
        super.onCreate()
        Log.d("MyBoundService", "onCreate called")
        startNotification()
        isRunning.value = true
        thread(start = true) {
            while (isRunning.value) {
                val randomNumber = mGenerator.nextInt(100)
                randomNumberLiveData.postValue(randomNumber)
                createOrUpdateNotification()
                Thread.sleep(1000)
            }
        }
    }

    /**
     * Called when the service is unbounded - here we set that the thread should no longer be running and kills the notification
     */
    override fun onDestroy() {
        super.onDestroy()
        isRunning.value = false
        val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.cancel(1)
    }


    /**
     * Used for creating and starting notification
     * whenever we start our Bound service
     */
    private fun startNotification() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            createOrUpdateNotification()
        } else {
            println("Here 2")
            TODO("VERSION.SDK_INT < O")
        }
    }

    /**
     * Used for creating or updating the notification so it shows the generated number in real time.
     */
    private fun createOrUpdateNotification() {
        val builder = NotificationCompat.Builder(this, channelId)
            .setSmallIcon(R.drawable.settings_fill1_wght400_grad0_opsz48)
            .setContentTitle("Bound Service")
            .setContentText("Number is: ${randomNumberLiveData.value.toString()}")
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setAutoCancel(true)
        with(NotificationManagerCompat.from(this)) {
            // notificationId is a unique int for each notification that you must define
            notify(1, builder.build())
        }
    }
}